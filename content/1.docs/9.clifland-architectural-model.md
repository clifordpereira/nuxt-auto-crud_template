---
title: Clifland Architectural Model (CAM)
description: CAM is a three-tier strategy for building scalable apps without the maintenance debt of code generation.
---

## üèó The Three Pillars

| Tier Analogy | Repository | Entity | Focus |
| --- | --- | --- | --- |
| **Interface** | `nuxt-auto-crud` | **Core Module** | Dynamic RESTful CRUD, & Zod validation. |
| **Abstract Class** | `nuxt-auto-crud_template` | **Base App Template** | UI/UX (Nuxt UI 4), Auth & Authz, Dynamic Forms & Data Tables. |
| **Concrete Class** | `your-private-repo` | **Your App Instance** | Custom business logic and domain-specific schemas. |

---

## ‚öôÔ∏è Engineering Principles

### 1. Zero-Codegen (Runtime Reflection)
No files are generated for CRUD. The API and UI reflect your **Drizzle schemas** in real-time. Modifying a schema updates the entire stack instantly.

### 2. Single Source of Truth (SSOT)
The **Drizzle Schema** is the only authority:
* **Database**: Dictates table structures and constraints.
* **Backend**: Nitro handlers use schemas for zero-config Zod validation.
* **Frontend**: UI components hydrate forms and tables dynamically.

### 3. Agentic Readiness
Designed for **LLM Tooling** and **MCP Agents**.
* **`GET /api/_meta`**: A discovery endpoint that lets AI "read" your system's capabilities, relationships, and payload requirements without source code access.

---

## üöÄ Why CAM?
* **Low Debt**: Minimal boilerplate means minimal code to rot.
* **AI-Native**: Your API is structured for machine consumption out of the box.
* **Instant Updates**: Core improvements are inherited via a simple `bun add nuxt-auto-crud`.

## üõ† Extensibility
While schemas and permissions cover most use cases, you can extend functionality:
* **Default CRUD**: Consume the core module's [RESTful endpoints](/docs/usage-examples/custom-features) for standard operations.
* **Custom Logic**: Implement domain-specific Nitro handlers or connect to external microservices (Laravel, Django, etc.) while maintaining the NAC core for data management.